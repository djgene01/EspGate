esphome:
  name: maingate
  friendly_name: MainGate

esp32:
  board: esp32dev
  framework:
    type: esp-idf

logger:
  level: WARN

api:
  encryption:
    key: "1Rx21yr6pE3ZXYPmKoQNoVI6nfmrtGvDXH4x8IKu8lA="

ota:
  - platform: esphome
    password: "5af0ed008fe82ffdc22a98879bc43919"

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  ap:
    ssid: "Maingate Fallback Hotspot"
    password: "0XEIihSBTgMi"

captive_portal:

# ----------------- persistent/staging state -----------------
globals:
  # Two learned buttons (both perform same action chain)
  - id: b1_addr
    type: uint32_t
    restore_value: yes
    initial_value: '0'
  - id: b1_cmd
    type: uint32_t
    restore_value: yes
    initial_value: '0'
  - id: b2_addr
    type: uint32_t
    restore_value: yes
    initial_value: '0'
  - id: b2_cmd
    type: uint32_t
    restore_value: yes
    initial_value: '0'

  # Enrollment flow: 0=none, 1=btn1, 2=btn2
  - id: enroll_target
    type: uint8_t
    initial_value: '0'
  - id: cap_needed
    type: uint8_t
    initial_value: '0'
  - id: cap_address
    type: uint32_t
    initial_value: '0'
  - id: cap_command
    type: uint32_t
    initial_value: '0'

  # Debounce
  - id: last_fire_ms
    type: uint32_t
    initial_value: '0'

  # Motor state: 0=stopped, 1=forward, 2=reverse
  - id: motor_state
    type: uint8_t
    restore_value: no
    initial_value: '0'

  # Remember the last completed/forced direction (1=forward, 2=reverse)
  - id: last_dir
    type: uint8_t
    restore_value: no
    initial_value: '0'

  # Auto-close state flag
  - id: auto_close_armed
    type: bool
    restore_value: no
    initial_value: 'false'

remote_receiver:
  pin:
    number: GPIO33
    inverted: false
  filter: 2us
  idle: 4ms
  buffer_size: 2048
  dump: keeloq

  on_keeloq:
    then:
      - lambda: |-
          const uint32_t QUIET_MS = 350;  // enrollment capture quiet time
          const uint32_t MIN_GAP  = 800;  // ignore RF repeat bursts

          uint32_t now = millis();
          static uint32_t last_cap_ms = 0;
          bool can_capture = (now - last_cap_ms) > QUIET_MS;

          // ---------- Enrollment ----------
          if (id(enroll_target) != 0 && id(cap_needed) > 0 && can_capture) {
            last_cap_ms = now;
            if (id(cap_needed) == 2) {
              id(cap_address) = x.address;
              id(cap_command) = x.command;
              id(cap_needed) = 1;
            } else {
              if (x.address == id(cap_address) && x.command == id(cap_command)) {
                if (id(enroll_target) == 1) {
                  id(b1_addr)=id(cap_address); id(b1_cmd)=id(cap_command);
                  id(rf_b1_info).publish_state("ok");
                } else {
                  id(b2_addr)=id(cap_address); id(b2_cmd)=id(cap_command);
                  id(rf_b2_info).publish_state("ok");
                }
                id(enroll_target)=0; id(cap_address)=0; id(cap_command)=0; id(cap_needed)=0;
              } else {
                id(cap_needed)=2;
                if (id(enroll_target) == 1) id(rf_b1_info).publish_state("mismatch; retry");
                else                         id(rf_b2_info).publish_state("mismatch; retry");
              }
            }
            return; // don't trigger motors during enrollment
          }

          // ---------- Runtime matching ----------
          auto match = [&](uint32_t a, uint32_t c){ return a!=0 && c!=0 && x.address==a && x.command==c; };
          bool isAny = match(id(b1_addr), id(b1_cmd)) || match(id(b2_addr), id(b2_cmd));
          if (!isAny) return;

          if (now - id(last_fire_ms) < MIN_GAP) return;   // debounce RF repeats
          id(last_fire_ms) = now;

          // Any manual remote press cancels pending auto-close immediately.
          id(auto_close_armed) = false;
          id(cancel_auto_close_btn).execute();  // FIX: execute script, don't press

          // Behaviour (your sequence):
          // - Press -> Reverse
          // - Press while Reverse -> Stop (remember last_dir=reverse)
          // - Press while Stopped after reversing -> Forward
          // - Press while Forward -> Stop
          if (id(motor_state) == 2) {
            id(motor_stop_btn).press();
          } else if (id(motor_state) == 1) {
            id(motor_stop_btn).press();
          } else if (id(motor_state) == 0 && id(last_dir) == 2) {
            id(motor_forward_btn).press();
          } else {
            id(motor_reverse_btn).press();
          }

  on_raw:
    then:
      - binary_sensor.template.publish:
          id: rf_activity
          state: ON
      - delay: 120ms
      - binary_sensor.template.publish:
          id: rf_activity
          state: OFF

# ----------------- RF UI -----------------
text_sensor:
  - platform: template
    id: rf_b1_info
    name: "RF Btn #1 (learn)"
    icon: mdi:key-star
    update_interval: never
  - platform: template
    id: rf_b2_info
    name: "RF Btn #2 (learn)"
    icon: mdi:key-star
    update_interval: never

binary_sensor:
  - platform: template
    id: rf_activity
    name: "RF Activity"
    device_class: moving

# ----------------- Relays and Auto-Close Switches -----------------
switch:
  - platform: gpio
    pin: 26
    id: relay1
    name: "Relay 1 (M1)"
    inverted: true
    restore_mode: ALWAYS_OFF

  - platform: gpio
    pin: 27
    id: relay2
    name: "Relay 2 (M2)"
    inverted: true
    restore_mode: ALWAYS_OFF

  - platform: template
    id: auto_close_enabled
    name: "Auto Close Enabled"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF   # <â€” replaces deprecated restore_state
    turn_on_action:
      - lambda: '/* no-op, state persisted */'
    turn_off_action:
      - script.stop: auto_close_timer
      - lambda: |-
          id(auto_close_armed) = false;

# ----------------- Numbers -----------------
number:
  - platform: template
    id: auto_close_timeout
    name: "Auto Close Timeout (s)"
    optimistic: true
    min_value: 0
    max_value: 240
    step: 1
    initial_value: 30

  - platform: template
    id: forward_time
    name: "Motor Forward Run Time"
    optimistic: true
    min_value: 1
    max_value: 10
    step: 1
    initial_value: 8

  - platform: template
    id: reverse_time
    name: "Motor Reverse Run Time"
    optimistic: true
    min_value: 1
    max_value: 10
    step: 1
    initial_value: 8

# ----------------- Scripts (stoppable runs) -----------------
script:
  - id: run_forward
    mode: restart
    then:
      # Any start of motion cancels auto-close
      - script.stop: auto_close_timer
      - lambda: |-
          id(auto_close_armed) = false;

      - switch.turn_on: relay1
      - switch.turn_off: relay2
      - lambda: |-
          id(motor_state) = 1;
      - delay: !lambda 'return (int)id(forward_time).state * 1000;'
      - switch.turn_off: relay1
      - switch.turn_off: relay2
      - lambda: |-
          id(last_dir) = 1;
          id(motor_state) = 0;
          // No auto-close arming after forward completes (closing).

  - id: run_reverse
    mode: restart
    then:
      # Any start of motion cancels auto-close (if previously armed)
      - script.stop: auto_close_timer
      - lambda: |-
          id(auto_close_armed) = false;

      - switch.turn_off: relay1
      - switch.turn_on: relay2
      - lambda: |-
          id(motor_state) = 2;
      - delay: !lambda 'return (int)id(reverse_time).state * 1000;'
      - switch.turn_off: relay1
      - switch.turn_off: relay2
      - lambda: |-
          id(last_dir) = 2;
          id(motor_state) = 0;
      # Arm auto-close ONLY after a natural (full) reverse run completes
      - if:
          condition:
            and:
              - switch.is_on: auto_close_enabled
              - lambda: 'return (int)id(auto_close_timeout).state > 0;'
          then:
            - script.execute: auto_close_timer

  - id: auto_close_timer
    mode: restart
    then:
      - lambda: |-
          id(auto_close_armed) = true;
      - delay: !lambda 'return (int)id(auto_close_timeout).state * 1000;'
      - lambda: |-
          // Only close if still armed, still stopped, last action was reverse,
          // and auto-close is still enabled.
          if (id(auto_close_armed) &&
              id(motor_state) == 0 &&
              id(last_dir) == 2) {
            id(motor_forward_btn).press();
          }
          id(auto_close_armed) = false;

  - id: cancel_auto_close_btn
    mode: restart
    then:
      - script.stop: auto_close_timer
      - lambda: |-
          id(auto_close_armed) = false;

# ----------------- Control Buttons -----------------
button:
  # Enrollment (two buttons total)
  - platform: template
    name: "Learn Button #1 (KeeLoq)"
    id: rf_enroll_b1
    on_press:
      - lambda: |-
          id(enroll_target) = 1; id(cap_needed) = 2; id(rf_b1_info).publish_state("arming");

  - platform: template
    name: "Learn Button #2 (KeeLoq)"
    id: rf_enroll_b2
    on_press:
      - lambda: |-
          id(enroll_target) = 2; id(cap_needed) = 2; id(rf_b2_info).publish_state("arming");

  # Motor control (script-driven; stoppable)
  - platform: template
    name: "Motor Forward"
    id: motor_forward_btn
    on_press:
      - script.stop: auto_close_timer
      - lambda: |-
          id(auto_close_armed) = false;
      - script.stop: run_reverse
      - script.execute: run_forward

  - platform: template
    name: "Motor Reverse"
    id: motor_reverse_btn
    on_press:
      - script.stop: auto_close_timer
      - lambda: |-
          id(auto_close_armed) = false;
      - script.stop: run_forward
      - script.execute: run_reverse

  - platform: template
    name: "Motor Stop"
    id: motor_stop_btn
    on_press:
      # capture last direction before clearing
      - lambda: |-
          if (id(motor_state) == 1 || id(motor_state) == 2) id(last_dir) = id(motor_state);
      - script.stop: run_forward
      - script.stop: run_reverse
      - switch.turn_off: relay1
      - switch.turn_off: relay2
      - lambda: |-
          id(motor_state) = 0;
      # Stopping with remote cancels pending auto-close
      - script.stop: auto_close_timer
      - lambda: |-
          id(auto_close_armed) = false;

web_server:
  port: 80
